<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>YoonLog</title><link href="http://blog.ryumiel.net/" rel="alternate"></link><link href="http://blog.ryumiel.net/feeds/igalia.atom.xml" rel="self"></link><id>http://blog.ryumiel.net/</id><updated>2014-12-02T17:20:00+09:00</updated><entry><title>Introducing ThreadedÂ Compositor</title><link href="http://blog.ryumiel.net/articles/introducing-threaded-compositor/" rel="alternate"></link><updated>2014-12-02T17:20:00+09:00</updated><author><name>Gwang Yoon Hwang</name></author><id>tag:blog.ryumiel.net,2014-12-02:articles/introducing-threaded-compositor/</id><summary type="html">&lt;p&gt;Since &lt;span class="caps"&gt;CSS&lt;/span&gt; Animation appeared, the graphics performance of WebKit has become an important issue, especially in embedded systems world. Many users (including me) want fancy and stunning user interfaces, even in a small handset device which have very restricted &lt;span class="caps"&gt;CPU&lt;/span&gt; and &lt;span class="caps"&gt;GPU&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Luckily, I could work through the years to improve the graphics performance of &lt;a class="reference external" href="http://webkit.org"&gt;WebKit&lt;/a&gt;. And with the support from colleagues in &lt;a class="reference external" href="http://www.igalia.com"&gt;Igalia&lt;/a&gt;, I just finished to make the Threaded Compositor for &lt;a class="reference external" href="http://webkitgtk.org"&gt;WebKitGTK+&lt;/a&gt; as a review-ready&amp;nbsp;state.&lt;/p&gt;
&lt;p&gt;The Threaded Compositor focused to improve the performance of WebKitGTK+ for &lt;span class="caps"&gt;CSS&lt;/span&gt; Animation using dedicated thread for compositing. But not only &lt;span class="caps"&gt;CSS&lt;/span&gt; Animation, it also provides a way to improve the performance of scrolling, scaling, rendering of canvas and video&amp;nbsp;element.&lt;/p&gt;
&lt;p&gt;Before diving into the detail, it would be good to watch a video which introducing the Threaded&amp;nbsp;Compositor.&lt;/p&gt;
&lt;div class="youtube" align="center"&gt;&lt;iframe width="420" height="315" src="https://www.youtube.com/embed/PJSsEiNasow" frameborder="0"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;&lt;a class="reference external" href="http://youtu.be/PJSsEiNasow"&gt;Click here if a video does not appear above this&amp;nbsp;text.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The example used in this video can be accessed from &lt;a class="reference external" href="http://ryumiel.github.io/spread"&gt;here&lt;/a&gt;.
I modified the &lt;a class="reference external" href="http://github.com/MathiasPaumgarten/spread"&gt;original version&lt;/a&gt; to run automatically for benchmarking&amp;nbsp;purpose.&lt;/p&gt;
&lt;p&gt;Also, the current implementation of Threaded Compositor is available on the &lt;a class="reference external" href="http://github.com/ryumiel/webkit-experimental/tree/threaded-compositor"&gt;github&lt;/a&gt;. It is based on the WebKit&amp;nbsp;r176538.&lt;/p&gt;
&lt;div class="section" id="motivation"&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;The main-thread is where everything gets executed, including layout, JavaScript execution, and other heavy operations. Thus, running accelerated compositing in the main-thread severely limits responsiveness and rendering performance. By having a separate thread for compositing, we can bring a significant performance improvement in scrolling, zooming, and&amp;nbsp;rendering.&lt;/p&gt;
&lt;p&gt;Currently, several ports have already implemented a way to perform compositing off the main-thread. Coordinate Graphics, which is used by Qt and &lt;span class="caps"&gt;EFL&lt;/span&gt;, runs accelerated compositing in &lt;span class="caps"&gt;UI&lt;/span&gt; Process, and Chromium has implemented Compositor Thread that runs off the main render&amp;nbsp;thread.&lt;/p&gt;
&lt;p&gt;Threaded Compositor is a threaded model of Coordinated Graphics. Unlike Coordinated Graphics, it composites contents in the dedicated thread of Web Process and doesn&amp;#8217;t use complicated inter-process shareable textures. Because of that, it is much easier to implement other multi-threaded rendering techniques which is covered at &lt;a class="reference internal" href="#compositing-the-media-and-the-canvas"&gt;Compositing the Media and the Canvas&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="off-the-main-thread-animation"&gt;
&lt;h3&gt;Off-the-main-thread&amp;nbsp;Animation&lt;/h3&gt;
&lt;p&gt;Compositing a contents using OpenGL[&lt;span class="caps"&gt;ES&lt;/span&gt;] is a basic technique to accelerate &lt;span class="caps"&gt;CSS&lt;/span&gt; animations. However, even we are using &lt;span class="caps"&gt;GPU&lt;/span&gt; accelerated compositing, we can face a V-sync pitfall. ( This happens more frequently in the embedded systems. )
Most of &lt;span class="caps"&gt;GPU&lt;/span&gt; uses V-sync (Vertical synchronization) to prevent &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Screen_tearing"&gt;the screen tearing&lt;/a&gt; problem. It may blocks OpenGL&amp;#8217;s SwapBuffer call at most 16 ms - if the monitor&amp;#8217;s refresh rate is 60 Hz - until the next vblank&amp;nbsp;interrupt.&lt;/p&gt;
&lt;p&gt;As you can see in the below diagram, this problem can waste the main-thread&amp;#8217;s &lt;span class="caps"&gt;CPU&lt;/span&gt;&amp;nbsp;time.&lt;/p&gt;
&lt;img alt="A diagram to visualize rendering pipeline of the current WebKitGTK+." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Vsync2.png" /&gt;
&lt;p&gt;Again, when the main thread executing OpenGL[&lt;span class="caps"&gt;ES&lt;/span&gt;]&amp;#8217;s SwapBuffer call, the driver should wait V-sync interrupt from the &lt;span class="caps"&gt;DRM&lt;/span&gt;/&lt;span class="caps"&gt;KMS&lt;/span&gt; module.
The above diagram shows the worst case scenario. The main-thread could render 6 frames in given time if there was no V-sync problem. But with the V-sync, it renders just 4 frames.
It can be happened more frequently in embedded environments which have less powerful &lt;span class="caps"&gt;CPU&lt;/span&gt; and &lt;span class="caps"&gt;GPU&lt;/span&gt;.&lt;/p&gt;
&lt;img alt="A diagram to visualize rendering pipeline of the Threaded Compositor." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Vsync1.png" /&gt;
&lt;p&gt;To overcome this problem, we uses a very common technique to use a different thread to update screen.
As visualized at above diagram, the compositing thread takes all overheads from the V-sync problem. The main-thread can do other job while the compositing thread handles OpenGL calls. (Purple rectangles in the main-thread indicate inter-thread&amp;nbsp;overheads.)&lt;/p&gt;
&lt;p&gt;Moreover, the Threaded Compositor accelerates &lt;span class="caps"&gt;CSS&lt;/span&gt; Animations,&amp;nbsp;also.&lt;/p&gt;
&lt;p&gt;Because all of the layer properties (including GraphicsLayerAnimation) are passed to the compositing thread,
it can make available to run &lt;span class="caps"&gt;CSS&lt;/span&gt; animations on the compositing thread without interrupting the main-thread.
When CoordinatedGraphicsScene finishes to render a scene, it will check is there any running animations in the its layer tree. If there are active one, it sets a timer to render a scene&amp;nbsp;itself.&lt;/p&gt;
&lt;p&gt;Attached sequence diagram can be helpful to understand this&amp;nbsp;idea.&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Update_Animation.png"&gt;&lt;img alt="A sequence diagram of the updating animation in the Threaded Compositor" class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Update_Animation.png" /&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="section" id="scrolling-and-scaling"&gt;
&lt;h3&gt;Scrolling and&amp;nbsp;Scaling&lt;/h3&gt;
&lt;p&gt;Scrolling and Scaling are also expensive job especially in the embedded&amp;nbsp;device.&lt;/p&gt;
&lt;p&gt;When we are scaling a web page, WebCore needs to update whole layout of its web page. As all of us knows, it is really expensive operation in the embedded&amp;nbsp;platform.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scaling procedure of the current WebKitGTK+." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Normal_Scaling.png" /&gt;
&lt;p&gt;Let&amp;#8217;s assume that a user tries to scale a web page using a two finger gesture. The WebCore in the Web Process tries to produce scaled web page with a exact layout as soon as possible. However, if it is a embedded device, it can need more than 100 ms - 10&amp;nbsp;fps.&lt;/p&gt;
&lt;p&gt;The Threaded Compositor renders a web page with a requested scale using its cached layer tree. By doing like that, we can give a immediate visual feed back to the user. And re-layouted web page will be updated&amp;nbsp;later.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scaling procedure of the Threaded Compositor." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Threaded_Scaling.png" /&gt;
&lt;p&gt;It is similar in the scrolling operation. When we are scrolling the web page, this operation doesn&amp;#8217;t need a huge re-layout operation.
But it needs re-painting and bliting operation to update a web&amp;nbsp;page.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scrolling procedure of the current WebKitGTK+." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Normal_Scrolling.png" /&gt;
&lt;p&gt;Because the Threaded Compositor uses TILED_BACKING_STORE, it can render the scrolled web page with cached tiles with a minimal latency.
During ThreadedCompositor renders a web page, the main-thread scrolls &amp;quot;actual&amp;quot; view. Whenever the main-thread finishes &amp;quot;actual&amp;quot; scroll, these changes are collected by CompositingCoordinator. And these changes are passed to the ThreadedCompositor to update the&amp;nbsp;view.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scrolling procedure of the Threaded Compositor." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Threaded_Scrolling.png" /&gt;
&lt;p&gt;Unfortunately, these optimization is only supported when we are using fixed layout. To support this without fixed layout, we need to refactor TILED_BACKING_STORE in WebKit and implement proper overlay scrollbars in&amp;nbsp;WebKitGTK+.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="compositing-the-media-and-the-canvas"&gt;
&lt;h3&gt;Compositing the Media and the&amp;nbsp;Canvas&lt;/h3&gt;
&lt;p&gt;Not only &lt;span class="caps"&gt;CSS3&lt;/span&gt; Animation and scaling but also the video and canvas can be accelerated by the Threaded Compositor.
Because it is little bit out of scope of this post - Because it is not implemented for upstreaming - I&amp;#8217;ll only describe about it briefly&amp;nbsp;here.&lt;/p&gt;
&lt;p&gt;In the TextureMapper, Media (Plugins, Video element, &amp;#8230;) and Canvas (WebGL, 2D Canvas) can be rendered by implementing TextureMapperPlatformLayer. Most important interface of the TextureMapperPlatformLayer is TextureMapperPlatformLayerClient::setPlatformLayerNeedsDisplay which requests the compositor to composite the its&amp;nbsp;contents.&lt;/p&gt;
&lt;p&gt;If the actual renderer of a Media and a Canvas element runs on off-the-main-thread, it is possible to bypass the main-thread entirely. The renderer can calls TextureMapperPlatformLayerClient::setPlatformLayerNeedsDisplay when it updates its result from its own thread. And compositing thread will composite the result without using the&amp;nbsp;main-thread.&lt;/p&gt;
&lt;img alt="A diagram to visualize rendering pipeline of for Canvas and Video." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Platform_Layers.png" /&gt;
&lt;p&gt;Also, if the target platform supports &lt;a class="reference external" href="https://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_stream_consumer_gltexture.txt"&gt;streams of texture&lt;/a&gt;, we can avoid pipeline hazards when drawing video layers in modern mobile GPUs which uses tile based&amp;nbsp;rendering.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;This performance comparison was presented in Linux.Conf.&lt;span class="caps"&gt;AU&lt;/span&gt; 2013.
It is based on pretty old implementation but it shows meaningful performance improvement compare to plain TextureMapper method.
I could not regenerate this result using my current laptop because it is too fast to make stressed condition.
I hope I can share updated the performance comparison using the embedded device&amp;nbsp;soon.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Test Cases &lt;a class="footnote-reference" href="#id2" id="id1"&gt;[*]&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;leaves&amp;nbsp;n&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Modified the famous accelerated compositing example, &lt;a class="reference external" href="https://www.webkit.org/blog-files/leaves/"&gt;WebKit Leaves&lt;/a&gt;, to draw n&amp;nbsp;leaves.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3DCube&amp;nbsp;n&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;n cubes rotating using &lt;span class="caps"&gt;CSS3&lt;/span&gt;&amp;nbsp;animation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Test&amp;nbsp;Environment&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Prototype of Threaded Compositor Implementation based on&amp;nbsp;r134883&lt;/li&gt;
&lt;li&gt;WebKit2 Gtk+&amp;nbsp;r140386&lt;/li&gt;
&lt;li&gt;Intel Core i5-2400 3.10Ghz, Geforce &lt;span class="caps"&gt;GTS450&lt;/span&gt;, Ubuntu 12.04&amp;nbsp;x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="19%" /&gt;
&lt;col width="36%" /&gt;
&lt;col width="28%" /&gt;
&lt;col width="17%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Tests&lt;/th&gt;
&lt;th class="head"&gt;ThreadedCompositor (fps)&lt;/th&gt;
&lt;th class="head"&gt;WebKit2 Gtk+ (fps)&lt;/th&gt;
&lt;th class="head"&gt;Improved %&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/leaves500NoDelay/"&gt;leaves500&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;58.96&lt;/td&gt;
&lt;td&gt;35.86&lt;/td&gt;
&lt;td&gt;64.42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/leaves1000NoDelay/"&gt;leaves1000&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;58.98&lt;/td&gt;
&lt;td&gt;25.88&lt;/td&gt;
&lt;td&gt;127.90&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/leaves2000NoDelay/"&gt;leaves2000&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;32.98&lt;/td&gt;
&lt;td&gt;18.04&lt;/td&gt;
&lt;td&gt;82.82&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/3DCube360NoDelay/"&gt;3DCube360&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;57.27&lt;/td&gt;
&lt;td&gt;32.09&lt;/td&gt;
&lt;td&gt;78.47&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/3DCube640NoDelay/"&gt;3DCube640&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;33.64&lt;/td&gt;
&lt;td&gt;23.52&lt;/td&gt;
&lt;td&gt;43.03&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[*]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;These tests are made by &lt;a class="reference external" href="http://company100.com"&gt;Company 100&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="class-diagram"&gt;
&lt;h2&gt;Class&amp;nbsp;Diagram&lt;/h2&gt;
&lt;p&gt;I made this diagram to help my understanding during the implementation, but It would be good to share to help others who are interested in&amp;nbsp;it.&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Threaded_Compositor.png"&gt;&lt;img alt="A class diagram of the Threaded Compositor" class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Threaded_Compositor.png" /&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;CompositingCoordinator&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A class takes the responsibility of managing compositing resources in the&amp;nbsp;main-thread.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ThreadedCompositor&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class has a dedicate thread for compositing. It owns ViewportController and CoordinatedGraphicsScene to render scene on the actual&amp;nbsp;surface.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ThreadedCoordinatedLayerTreeHost&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A concrete class of LayerTreeHost and CompositingCoordinator::Client for CoordinatedGraphics. And it has ThreadedCompositor to use the Threaded&amp;nbsp;Compositor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;CoordinatedGraphicsScene&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A class which has a complete scene graph and rendering functionality. It synchronizes its own scene graph with a graphics layer tree in compositing&amp;nbsp;coordinator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ThreadSafeCoordinatedSurface&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class implements a surface using ImageBuffer as a backend to use in the Web&amp;nbsp;Process.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;TextureMapperLayer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It has actual properties to render a&amp;nbsp;layer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ViewportController&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class is responsible to handle scale factor and scrolling position in the compositing&amp;nbsp;thread.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the main-thread, all of the visual changes of each GraphicsLayer are passed to CompositingCoordinator via CoordinatedGraphicsLayer. And CompositingCoordinator collects state changes from the GraphicsLayer tree when it is requested to do&amp;nbsp;so.&lt;/p&gt;
&lt;p&gt;From this point, Threaded Compositor and Coordinated Graphics behaves&amp;nbsp;differently.&lt;/p&gt;
&lt;p&gt;In Coordinated Graphics, the collected state changes of the layer tree is encoded and passed to CoordinatedLayerTreeHostProxy in UIProcess. And CoordinatedGraphicsScene applies these state changes to its own TextureMapperLayer tree and renders these on the frame&amp;nbsp;buffer.&lt;/p&gt;
&lt;p&gt;But in Threaded Compositor, these states are passed to CoordinatedGraphicsScene which owned by ThreadedCompositor. ThreadedCompositor has its own RunLoop and thread, all of the actual compositing operations are executed in the dedicated compositing thread in Web&amp;nbsp;Process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="current-status"&gt;
&lt;h2&gt;Current&amp;nbsp;Status&lt;/h2&gt;
&lt;p&gt;Most of re-factoring for Threaded Compositor in Coordinated Graphics side was done in the last&amp;nbsp;year.&lt;/p&gt;
&lt;p&gt;However, upstreaming of Threaded Compositor was delayed to various issues.
I had to simplify the design (which was quite complicate at that time) and resolve various issues Before starting upstreaming&amp;nbsp;process.&lt;/p&gt;
&lt;p&gt;In this year, WebKitGTK+ decided to deprecate WebKit1. Because of that it was possible to make much less complicated design.
Also, I fixed the Threaded Compositor not to break current behavior of WebKitGTK+ without fixed&amp;nbsp;layout.&lt;/p&gt;
&lt;p&gt;I&amp;#8217;m happy that I can start upstreaming process of this implementation, from now&amp;nbsp;on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="things-to-do"&gt;
&lt;h2&gt;Things To&amp;nbsp;Do&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Reduce memory uses when updating&amp;nbsp;texture&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;RenderObjects draw its contents to UpdateAtlas to pass bitmaps to the compositing thread. However, The size of each UpdateAtlas is &lt;span class="caps"&gt;4MB&lt;/span&gt;. It is quite big memory consumption in the embedded device. Still, I couldn&amp;#8217;t find a way to solve it without using proprietary &lt;span class="caps"&gt;GPU&lt;/span&gt;&amp;nbsp;driver.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Avoid pipeline hazards in the mobile &lt;span class="caps"&gt;GPU&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Modern mobile GPUs uses tile-based [deferred] rendering. These GPUs can render multiple frames (~ 3 frames) concurrently to overcome its low performance. It is well working technique in the game industry which uses static&amp;nbsp;textures.&lt;/li&gt;
&lt;li&gt;In the WebKit, most of textures are dynamically generated. Whenever we are updating a texture using texSubImage2D, &lt;span class="caps"&gt;GPU&lt;/span&gt; would be stalled because it would be used in the previous rendering&amp;nbsp;call.&lt;/li&gt;
&lt;li&gt;To avoid this problem, chromium uses &lt;a class="reference external" href="http://src.chromium.org/viewvc/chrome/trunk/src/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_mailbox.txt"&gt;producer/consumer model of&amp;nbsp;texture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We can create a wrapper for a texture which provides multiple buffering. In this way we can avoid the pipeline&amp;nbsp;hazards.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Reduce the maintenance&amp;nbsp;burden&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;we need to re-factor Coordinated Graphics to share codes with Apple&amp;#8217;s &lt;span class="caps"&gt;UI&lt;/span&gt; &lt;span class="caps"&gt;SIDE&lt;/span&gt; &lt;span class="caps"&gt;COMPOSITING&lt;/span&gt; codes. Most of messages are duplicated. So it can be easily done by defining platform specific&amp;nbsp;parts.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Accelerate the performance of 2D Canvas element and Video&amp;nbsp;element&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It can be improved (relatively) easily as I described at &lt;a class="reference internal" href="#compositing-the-media-and-the-canvas"&gt;Compositing the Media and the Canvas&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Check the performance of Threaded Compositor in the embedded&amp;nbsp;device&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;I hope I can share about it&amp;nbsp;soon.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Most of all,&amp;nbsp;upstreaming!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="WebKit"></category><category term="WebKitGTK+"></category><category term="AcceleratedCompositing"></category><category term="Igalia"></category></entry></feed>