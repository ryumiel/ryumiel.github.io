<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>YoonLog</title><link>http://blog.ryumiel.net/</link><description></description><atom:link href="http://blog.ryumiel.net/feeds/webengine.rss.xml" rel="self"></atom:link><lastBuildDate>Thu, 04 Dec 2014 10:20:00 +0900</lastBuildDate><item><title>Introducing Threaded Compositor</title><link>http://blog.ryumiel.net/articles/introducing-threaded-compositor/</link><description>&lt;p&gt;Since &lt;span class="caps"&gt;CSS&lt;/span&gt; Animation appeared, the graphics performance of WebKit has become an important issue, especially in embedded systems world. Many users (including me) want fancy and stunning user interfaces, even in a small handset device which have very restricted &lt;span class="caps"&gt;CPU&lt;/span&gt; and &lt;span class="caps"&gt;GPU&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Luckily, I could work through the years to improve the graphics performance of &lt;a class="reference external" href="http://webkit.org"&gt;WebKit&lt;/a&gt;. And with the support from colleagues in &lt;a class="reference external" href="http://www.igalia.com"&gt;Igalia&lt;/a&gt;, I just finished to make the Threaded Compositor for &lt;a class="reference external" href="http://webkitgtk.org"&gt;WebKitGTK+&lt;/a&gt; as a review-ready state.&lt;/p&gt;
&lt;p&gt;The Threaded Compositor focused to improve the performance of WebKitGTK+ for &lt;span class="caps"&gt;CSS&lt;/span&gt; Animation using dedicated thread for compositing. But not only &lt;span class="caps"&gt;CSS&lt;/span&gt; Animation, it also provides a way to improve the performance of scrolling, scaling, rendering of canvas and video element.&lt;/p&gt;
&lt;p&gt;Before diving into the detail, it would be good to watch a video which introducing the Threaded Compositor.&lt;/p&gt;
&lt;div align="center" class="youtube"&gt;&lt;iframe frameborder="0" height="315" src="https://www.youtube.com/embed/PJSsEiNasow" width="420"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;p&gt;&lt;a class="reference external" href="http://youtu.be/PJSsEiNasow"&gt;Click here if a video does not appear above this text.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The example used in this video can be accessed from &lt;a class="reference external" href="http://ryumiel.github.io/spread"&gt;here&lt;/a&gt;.
I modified the &lt;a class="reference external" href="http://github.com/MathiasPaumgarten/spread"&gt;original version&lt;/a&gt; to run automatically for benchmarking purpose.&lt;/p&gt;
&lt;p&gt;Also, the current implementation of Threaded Compositor is available on the &lt;a class="reference external" href="http://github.com/ryumiel/webkit-experimental/tree/threaded-compositor"&gt;github&lt;/a&gt;. It is based on the WebKit r176538.&lt;/p&gt;
&lt;div class="section" id="motivation"&gt;
&lt;h2&gt;Motivation&lt;/h2&gt;
&lt;p&gt;The main-thread is where everything gets executed, including layout, JavaScript execution, and other heavy operations. Thus, running accelerated compositing in the main-thread severely limits responsiveness and rendering performance. By having a separate thread for compositing, we can bring a significant performance improvement in scrolling, zooming, and rendering.&lt;/p&gt;
&lt;p&gt;Currently, several ports have already implemented a way to perform compositing off the main-thread. Coordinate Graphics, which is used by Qt and &lt;span class="caps"&gt;EFL&lt;/span&gt;, runs accelerated compositing in &lt;span class="caps"&gt;UI&lt;/span&gt; Process, and Chromium has implemented Compositor Thread that runs off the main render thread.&lt;/p&gt;
&lt;p&gt;Threaded Compositor is a threaded model of Coordinated Graphics. Unlike Coordinated Graphics, it composites contents in the dedicated thread of Web Process and doesn’t use complicated inter-process shareable textures. Because of that, it is much easier to implement other multi-threaded rendering techniques which is covered at &lt;a class="reference internal" href="#compositing-the-media-and-the-canvas"&gt;Compositing the Media and the Canvas&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="off-the-main-thread-animation"&gt;
&lt;h3&gt;Off-the-main-thread Animation&lt;/h3&gt;
&lt;p&gt;Compositing a contents using OpenGL[&lt;span class="caps"&gt;ES&lt;/span&gt;] is a basic technique to accelerate &lt;span class="caps"&gt;CSS&lt;/span&gt; animations. However, even we are using &lt;span class="caps"&gt;GPU&lt;/span&gt; accelerated compositing, we can face a V-sync pitfall. ( This happens more frequently in the embedded systems. )
Most of &lt;span class="caps"&gt;GPU&lt;/span&gt; uses V-sync (Vertical synchronization) to prevent &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Screen_tearing"&gt;the screen tearing&lt;/a&gt; problem. It may blocks OpenGL’s SwapBuffer call at most 16 ms - if the monitor’s refresh rate is 60 Hz - until the next vblank interrupt.&lt;/p&gt;
&lt;p&gt;As you can see in the below diagram, this problem can waste the main-thread’s &lt;span class="caps"&gt;CPU&lt;/span&gt; time.&lt;/p&gt;
&lt;img alt="A diagram to visualize rendering pipeline of the current WebKitGTK+." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Vsync2.png" style="width: 100%;width: 2134px; height: auto; max-width: 100%;"/&gt;
&lt;p&gt;Again, when the main thread executing OpenGL[&lt;span class="caps"&gt;ES&lt;/span&gt;]’s SwapBuffer call, the driver should wait V-sync interrupt from the &lt;span class="caps"&gt;DRM&lt;/span&gt;/&lt;span class="caps"&gt;KMS&lt;/span&gt; module.
The above diagram shows the worst case scenario. The main-thread could render 6 frames in given time if there was no V-sync problem. But with the V-sync, it renders just 4 frames.
It can be happened more frequently in embedded environments which have less powerful &lt;span class="caps"&gt;CPU&lt;/span&gt; and &lt;span class="caps"&gt;GPU&lt;/span&gt;.&lt;/p&gt;
&lt;img alt="A diagram to visualize rendering pipeline of the Threaded Compositor." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Vsync1.png" style="width: 100%;width: 2134px; height: auto; max-width: 100%;"/&gt;
&lt;p&gt;To overcome this problem, we uses a very common technique to use a different thread to update screen.
As visualized at above diagram, the compositing thread takes all overheads from the V-sync problem. The main-thread can do other job while the compositing thread handles OpenGL calls. (Purple rectangles in the main-thread indicate inter-thread overheads.)&lt;/p&gt;
&lt;p&gt;Moreover, the Threaded Compositor accelerates &lt;span class="caps"&gt;CSS&lt;/span&gt; Animations, also.&lt;/p&gt;
&lt;p&gt;Because all of the layer properties (including GraphicsLayerAnimation) are passed to the compositing thread,
it can make available to run &lt;span class="caps"&gt;CSS&lt;/span&gt; animations on the compositing thread without interrupting the main-thread.
When CoordinatedGraphicsScene finishes to render a scene, it will check is there any running animations in the its layer tree. If there are active one, it sets a timer to render a scene itself.&lt;/p&gt;
&lt;p&gt;Attached sequence diagram can be helpful to understand this idea.&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Update_Animation.png"&gt;&lt;img alt="A sequence diagram of the updating animation in the Threaded Compositor" class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Update_Animation.png" style="width: 100%;width: 1920px; height: auto; max-width: 100%;"/&gt;&lt;/a&gt;
&lt;/div&gt;
&lt;div class="section" id="scrolling-and-scaling"&gt;
&lt;h3&gt;Scrolling and Scaling&lt;/h3&gt;
&lt;p&gt;Scrolling and Scaling are also expensive job especially in the embedded device.&lt;/p&gt;
&lt;p&gt;When we are scaling a web page, WebCore needs to update whole layout of its web page. As all of us knows, it is really expensive operation in the embedded platform.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scaling procedure of the current WebKitGTK+." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Normal_Scaling.png" style="width: 100%;width: 1081px; height: auto; max-width: 100%;"/&gt;
&lt;p&gt;Let’s assume that a user tries to scale a web page using a two finger gesture. The WebCore in the Web Process tries to produce scaled web page with a exact layout as soon as possible. However, if it is a embedded device, it can need more than 100 ms - 10 fps.&lt;/p&gt;
&lt;p&gt;The Threaded Compositor renders a web page with a requested scale using its cached layer tree. By doing like that, we can give a immediate visual feed back to the user. And re-layouted web page will be updated later.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scaling procedure of the Threaded Compositor." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Threaded_Scaling.png" style="width: 100%;width: 1397px; height: auto; max-width: 100%;"/&gt;
&lt;p&gt;It is similar in the scrolling operation. When we are scrolling the web page, this operation doesn’t need a huge re-layout operation.
But it needs re-painting and bliting operation to update a web page.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scrolling procedure of the current WebKitGTK+." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Normal_Scrolling.png" style="width: 100%;width: 1261px; height: auto; max-width: 100%;"/&gt;
&lt;p&gt;Because the Threaded Compositor uses TILED_BACKING_STORE, it can render the scrolled web page with cached tiles with a minimal latency.
During ThreadedCompositor renders a web page, the main-thread scrolls "actual" view. Whenever the main-thread finishes "actual" scroll, these changes are collected by CompositingCoordinator. And these changes are passed to the ThreadedCompositor to update the view.&lt;/p&gt;
&lt;img alt="A simplified diagram to visualize scrolling procedure of the Threaded Compositor." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Threaded_Scrolling.png" style="width: 100%;width: 1563px; height: auto; max-width: 100%;"/&gt;
&lt;p&gt;Unfortunately, these optimization is only supported when we are using fixed layout. To support this without fixed layout, we need to refactor TILED_BACKING_STORE in WebKit and implement proper overlay scrollbars in WebKitGTK+.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="compositing-the-media-and-the-canvas"&gt;
&lt;h3&gt;Compositing the Media and the Canvas&lt;/h3&gt;
&lt;p&gt;Not only &lt;span class="caps"&gt;CSS3&lt;/span&gt; Animation and scaling but also the video and canvas can be accelerated by the Threaded Compositor.
Because it is little bit out of scope of this post - Because it is not implemented for upstreaming - I’ll only describe about it briefly here.&lt;/p&gt;
&lt;p&gt;In the TextureMapper, Media (Plugins, Video element, …) and Canvas (WebGL, 2D Canvas) can be rendered by implementing TextureMapperPlatformLayer. Most important interface of the TextureMapperPlatformLayer is TextureMapperPlatformLayerClient::setPlatformLayerNeedsDisplay which requests the compositor to composite the its contents.&lt;/p&gt;
&lt;p&gt;If the actual renderer of a Media and a Canvas element runs on off-the-main-thread, it is possible to bypass the main-thread entirely. The renderer can calls TextureMapperPlatformLayerClient::setPlatformLayerNeedsDisplay when it updates its result from its own thread. And compositing thread will composite the result without using the main-thread.&lt;/p&gt;
&lt;img alt="A diagram to visualize rendering pipeline of for Canvas and Video." class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Simplified_Platform_Layers.png" style="width: 100%;width: 1368px; height: auto; max-width: 100%;"/&gt;
&lt;p&gt;Also, if the target platform supports &lt;a class="reference external" href="https://www.khronos.org/registry/egl/extensions/KHR/EGL_KHR_stream_consumer_gltexture.txt"&gt;streams of texture&lt;/a&gt;, we can avoid pipeline hazards when drawing video layers in modern mobile GPUs which uses tile based rendering.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="performance"&gt;
&lt;h2&gt;Performance&lt;/h2&gt;
&lt;p&gt;This performance comparison was presented in Linux.Conf.&lt;span class="caps"&gt;AU&lt;/span&gt; 2013.
It is based on pretty old implementation but it shows meaningful performance improvement compare to plain TextureMapper method.
I could not regenerate this result using my current laptop because it is too fast to make stressed condition.
I hope I can share updated the performance comparison using the embedded device soon.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Test Cases &lt;a class="footnote-reference" href="#id2" id="id1"&gt;[*]&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;leaves n&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Modified the famous accelerated compositing example, &lt;a class="reference external" href="https://www.webkit.org/blog-files/leaves/"&gt;WebKit Leaves&lt;/a&gt;, to draw n leaves.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;3DCube n&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;n cubes rotating using &lt;span class="caps"&gt;CSS3&lt;/span&gt; animation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Test Environment&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Prototype of Threaded Compositor Implementation based on r134883&lt;/li&gt;
&lt;li&gt;WebKit2 Gtk+ r140386&lt;/li&gt;
&lt;li&gt;Intel Core i5-2400 3.10Ghz, Geforce &lt;span class="caps"&gt;GTS450&lt;/span&gt;, Ubuntu 12.04 x86_64&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="19%"&gt;&lt;/col&gt;
&lt;col width="36%"&gt;&lt;/col&gt;
&lt;col width="28%"&gt;&lt;/col&gt;
&lt;col width="17%"&gt;&lt;/col&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Tests&lt;/th&gt;
&lt;th class="head"&gt;ThreadedCompositor (fps)&lt;/th&gt;
&lt;th class="head"&gt;WebKit2 Gtk+ (fps)&lt;/th&gt;
&lt;th class="head"&gt;Improved %&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/leaves500NoDelay/"&gt;leaves500&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;58.96&lt;/td&gt;
&lt;td&gt;35.86&lt;/td&gt;
&lt;td&gt;64.42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/leaves1000NoDelay/"&gt;leaves1000&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;58.98&lt;/td&gt;
&lt;td&gt;25.88&lt;/td&gt;
&lt;td&gt;127.90&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/leaves2000NoDelay/"&gt;leaves2000&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;32.98&lt;/td&gt;
&lt;td&gt;18.04&lt;/td&gt;
&lt;td&gt;82.82&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/3DCube360NoDelay/"&gt;3DCube360&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;57.27&lt;/td&gt;
&lt;td&gt;32.09&lt;/td&gt;
&lt;td&gt;78.47&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;a class="reference external" href="http://black.company100.com/test/TC/3DCube640NoDelay/"&gt;3DCube640&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;33.64&lt;/td&gt;
&lt;td&gt;23.52&lt;/td&gt;
&lt;td&gt;43.03&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label"&gt;&lt;/col&gt;&lt;col&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[*]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;These tests are made by &lt;a class="reference external" href="http://company100.com"&gt;Company 100&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="class-diagram"&gt;
&lt;h2&gt;Class Diagram&lt;/h2&gt;
&lt;p&gt;I made this diagram to help my understanding during the implementation, but It would be good to share to help others who are interested in it.&lt;/p&gt;
&lt;a class="reference external image-reference" href="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Threaded_Compositor.png"&gt;&lt;img alt="A class diagram of the Threaded Compositor" class="align-center" src="http://blog.ryumiel.net/images/articles/Threaded_Compositor_Design_Threaded_Compositor.png" style="width: 100%;width: 1581px; height: auto; max-width: 100%;"/&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;CompositingCoordinator&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A class takes the responsibility of managing compositing resources in the main-thread.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ThreadedCompositor&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class has a dedicate thread for compositing. It owns ViewportController and CoordinatedGraphicsScene to render scene on the actual surface.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ThreadedCoordinatedLayerTreeHost&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A concrete class of LayerTreeHost and CompositingCoordinator::Client for CoordinatedGraphics. And it has ThreadedCompositor to use the Threaded Compositor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;CoordinatedGraphicsScene&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A class which has a complete scene graph and rendering functionality. It synchronizes its own scene graph with a graphics layer tree in compositing coordinator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ThreadSafeCoordinatedSurface&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class implements a surface using ImageBuffer as a backend to use in the Web Process.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;TextureMapperLayer&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It has actual properties to render a layer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ViewportController&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This class is responsible to handle scale factor and scrolling position in the compositing thread.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the main-thread, all of the visual changes of each GraphicsLayer are passed to CompositingCoordinator via CoordinatedGraphicsLayer. And CompositingCoordinator collects state changes from the GraphicsLayer tree when it is requested to do so.&lt;/p&gt;
&lt;p&gt;From this point, Threaded Compositor and Coordinated Graphics behaves differently.&lt;/p&gt;
&lt;p&gt;In Coordinated Graphics, the collected state changes of the layer tree is encoded and passed to CoordinatedLayerTreeHostProxy in UIProcess. And CoordinatedGraphicsScene applies these state changes to its own TextureMapperLayer tree and renders these on the frame buffer.&lt;/p&gt;
&lt;p&gt;But in Threaded Compositor, these states are passed to CoordinatedGraphicsScene which owned by ThreadedCompositor. ThreadedCompositor has its own RunLoop and thread, all of the actual compositing operations are executed in the dedicated compositing thread in Web Process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="current-status"&gt;
&lt;h2&gt;Current Status&lt;/h2&gt;
&lt;p&gt;Most of re-factoring for Threaded Compositor in Coordinated Graphics side was done in the last year.&lt;/p&gt;
&lt;p&gt;However, upstreaming of Threaded Compositor was delayed to various issues.
I had to simplify the design (which was quite complicate at that time) and resolve various issues Before starting upstreaming process.&lt;/p&gt;
&lt;p&gt;In this year, WebKitGTK+ decided to deprecate WebKit1. Because of that it was possible to make much less complicated design.
Also, I fixed the Threaded Compositor not to break current behavior of WebKitGTK+ without fixed layout.&lt;/p&gt;
&lt;p&gt;I’m happy that I can start upstreaming process of this implementation, from now on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="things-to-do"&gt;
&lt;h2&gt;Things To Do&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Reduce memory uses when updating texture&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;RenderObjects draw its contents to UpdateAtlas to pass bitmaps to the compositing thread. However, The size of each UpdateAtlas is &lt;span class="caps"&gt;4MB&lt;/span&gt;. It is quite big memory consumption in the embedded device. Still, I couldn’t find a way to solve it without using proprietary &lt;span class="caps"&gt;GPU&lt;/span&gt; driver.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Avoid pipeline hazards in the mobile &lt;span class="caps"&gt;GPU&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Modern mobile GPUs uses tile-based [deferred] rendering. These GPUs can render multiple frames (~ 3 frames) concurrently to overcome its low performance. It is well working technique in the game industry which uses static textures.&lt;/li&gt;
&lt;li&gt;In the WebKit, most of textures are dynamically generated. Whenever we are updating a texture using texSubImage2D, &lt;span class="caps"&gt;GPU&lt;/span&gt; would be stalled because it would be used in the previous rendering call.&lt;/li&gt;
&lt;li&gt;To avoid this problem, chromium uses &lt;a class="reference external" href="http://src.chromium.org/viewvc/chrome/trunk/src/gpu/GLES2/extensions/CHROMIUM/CHROMIUM_texture_mailbox.txt"&gt;producer/consumer model of texture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;We can create a wrapper for a texture which provides multiple buffering. In this way we can avoid the pipeline hazards.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Reduce the maintenance burden&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;we need to re-factor Coordinated Graphics to share codes with Apple’s &lt;span class="caps"&gt;UI&lt;/span&gt; &lt;span class="caps"&gt;SIDE&lt;/span&gt; &lt;span class="caps"&gt;COMPOSITING&lt;/span&gt; codes. Most of messages are duplicated. So it can be easily done by defining platform specific parts.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Accelerate the performance of 2D Canvas element and Video element&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It can be improved (relatively) easily as I described at &lt;a class="reference internal" href="#compositing-the-media-and-the-canvas"&gt;Compositing the Media and the Canvas&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Check the performance of Threaded Compositor in the embedded device&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;I hope I can share about it soon.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Most of all, upstreaming!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Gwang Yoon Hwang</dc:creator><pubDate>Thu, 04 Dec 2014 10:20:00 +0900</pubDate><guid>tag:blog.ryumiel.net,2014-12-02:articles/introducing-threaded-compositor/</guid><category>WebKit</category><category>WebKitGTK+</category><category>AcceleratedCompositing</category><category>Igalia</category></item></channel></rss>